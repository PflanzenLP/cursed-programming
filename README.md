## Welcome!
Hello there, I'm Zen, a computer science student at the brink of graduating. In my years of writing code, may it be for personal use or for my studies, I have encountered many bad coding habits. Some of them plain stupid, some funny, some actually problematic. I have collected so many stories worth telling, I decided to compile them into a collection for the world to see. Buckle up, we are going on a trip.

### Chapter 1: readability and repetitions
In my first steps programming I quickly discovered that readability is important. Quickly seeing what code does makes it easy to understand, so far so good. However when coding my first robot controller in "Robot Karol", I discovered that repeating an instruction once is more readable than a loop, especially when the entire behavior is already in a loop. So I opted for two of the same lines consecutively instead of a nested loop. Years later I did the same thing when coding a ComputerCraft turtle script in Lua for my modded Minecraft world. For demonstration purposes non-language specific examples are given in Python, since it is easily understood by most people.

### Chapter 2: error handling
Most high level languages have some kind of error handling behavior, for example try-catch in Java or try-except in Python. These can gracefully handle all types of named errors, i. e. TypeError, OverflowError, IndexError and so on. This is hugely helpful when dealing with uncertainty, like user input. However, I decided to completely abuse this system to prevent crashes instead of actually handling error right then and there. This is how the "except: pass" statement found its way into embarrassingly much of my code. Not only that, I also used this "feature" to simplify mass 2D matrix accesses. For example, when getting the adjacent 4 cells (or 8 for that matter), just adding or subtracting from indices will result in OutOfBounds errors. except: pass can handle these cases silently without having to complicatedly deal with these special cases. This example is presented in Java since Python also allows negative array indices, which is a whole different can of worms. Another example of cursed error handling can be found in chapter 3: data_query.py

### Chapter 3: generators and one-liners
Python has a beautiful feature called generators, basically instructions on how to build a list. Since generators need functions as blueprints on how to build the list, they also allow for lambda functions. For small generators, this can be fine, however it can also be brutally abused.
For my studies I did a course purely for credits. After gathering all the points I needed, I had some fun with my tutor and handed in a 130 character long expression. To be fair, a complicated data structure was given and we should query and print specific values, so obviously it was no "one-short-line" solution. Of course it could have easily been spread across multiple lines, but where is the fun in that?
This wasn't even the worst thing I did with generators. Just one semester later, again for a course purely for credits, I handed in an even longer and far more complicated one-liner making use of the Y-combinator, since for-loops where not allowed for this task. The goal by the way was a while-loop. Of course I don't write generators or one-liners this big for actual use in my own projects, but I am definitely having fun pushing the limits on them from time to time.

### Chapter 4: secure file search
Depending on your configuration and situation, the compiler might not find a file you try to access in your code using a simple file name. This is why I am still using full paths to represent file destinations whenever I work with multiple files. One example of this is my bachelors project. A robot controller script generates an image to update the background of a simulation. Since I don't start the controller from a terminal but the simulation software does it for me, I have no idea where the generated image will be placed when using the relative path and a execution entry point of god-knows where. My solution is admittedly brute-force and could definitely be resolved with a decent simulation config, however it has worked this way for me for all kinds of applications, so why change now?

### Chapter 5: getattr() and globals()
When running my robot experiments I need to change small things between runs manually, like switching up the active world the experiments take place in. Since several files all use information from secondary data files dependant on the active world, I would need to change variables in all of them. So I decided to use a central config file which I can change quickly. However some variables are not linked to the correct control variables (due to bad implementation, that's on me). Since I was in a time crunch when writing that code, refactoring was not an option. So, I did what every idiot would do in that situation an link the control variable directly to the name of the unlinked variables. This linkage is possible with the getattr() function for variables in other modules and the globals() function for the same file.